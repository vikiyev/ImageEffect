# Image Effects

This WebAssembly project applies a grayscale filter to an image.

# WebAssembly

WebAssembly is a language for the web to run apps at near native speeds. WebAssembly is a compilation target, which is a language targeted by a compiler.

# Rust

Rust is a statically typed, memory safe and highly performant language. Rust provides the following tools:

- rustup - managing different versions of Rust
- rustc - tool for compiling Rust code
- cargo - tool for managing Rust packages and projects

## Webpack

Webpack is used for minifying and bundling our assets. It can also be used to compile rust projects. We use the following libraries for the project: `webpack webpack-cli webpack-dev-server html-webpack-plugin`. For html bundling, we use webpack-create-html. Since Rust doesn't run on the browser, it needs to be compiled into wasm using `@wasm-tool/wasm-pack-plugin wasm-pack`.

We create a `webpack.config.js` file.

```javascript
const path = require("path");
const HTMLWebpackPlugin = require("html-webpack-plugin");
const WasmPackPlugin = require("@wasm-tool/wasm-pack-plugin");

module.exports = {
  entry: "./public/main.js",
  output: {
    path: path.resolve(__dirname, "dist"),
    filename: "index.js",
  },
  plugins: [
    new HTMLWebpackPlugin({
      template: "./public/index.html",
    }),
    new WasmPackPlugin({
      crateDirectory: path.resolve(__dirname, "."),
    }),
  ],
  experiments: {
    asyncWebAssembly: true,
  },
};
```

```json
  "scripts": {
    "serve": "webpack serve --mode=development",
    "build": "webpack --mode=production"
  },
```

We also need to tell rust to support external languages using the **lib** table.

```toml
[package]
name = "wasm"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
```

## Reading Files

We need to be able to send images from javascript to rust. We can do so by intercepting file uploads using events. We can convert from binary file into a string using FileReader.**readAsDataURL** which we will transfer to rust.

```javascript
function init() {
  const input = document.getElementById("upload");
  const fileReader = new FileReader();

  input.addEventListener("change", () => {
    fileReader.readAsDataURL(input.files[0]);

    fileReader.onloadend = () => {
      // remove metadata from the result
      const base64 = fileReader.result.replace(
        /^data:image\/(png|jpeg|jpg);base64,/,
        ""
      );
      console.log(input.files[0]);
      console.log(base64);
    };
  });
}

init();
```

## Importing Web Assembly

To import the wasm file generated by webpack, we use the `wasm-bindgen` crate which helps us export rust functions into javascript. We can add the following to the dependencies table of the `cargo.toml` file:

```toml
wasm-bindgen = "0.2.83"
```

```javascript
async function init() {
  let rustApp = null;

  try {
    rustApp = await import("../pkg/index.js");
  } catch (error) {
    console.error(error);
    return;
  }
}
```

## Writing in Rust

```javascript
let img_data_url = rustApp.grayscale(base64);
```

At this point, we can now write code in Rust. A function can be made public by adding the `pub` keyword. wasm-bindgen crate can export functions into javascript. The `web-sys` crate exports a set of javascript functions to rust. We can partially import console functions from the web-sys crate using:

```toml
[dependencies.web-sys]
version = "0.3.4"
features = ["console"]
```

## Transforming the Image

To decode base64, we can use the `base64` crate to convert the string back into binary data. The decode function will convert the base64 value into a vector. The `image` crate can be used for processing images. The **load_from_memory** function will store a copy of the image in memory for manipulation.

```rs
use wasm_bindgen::prelude::wasm_bindgen;
use web_sys::console::log_1 as log;
use base64::decode;
use image::load_from_memory;

#[wasm_bindgen]
pub fn grayscale(encoded_file: &str) {
  // decode base 64
  let base64_to_vector = decode(encoded_file).unwrap();
  log(&"Image decoded".into());

  // load image from memory
  let mut img = load_from_memory(&base64_to_vector).unwrap();
  log(&"Image loaded".into());

  // grayscale the image
  img = img.grayscale();
  log(&"Grayscale applied".into())
}
```

## Buffering and Encoding Image

Buffers are a feature for temporarily storing data. After a buffer has stored a file, we are allowed to read data from the buffer. The image is currently a DynamicImage. The conversion back to binary data takes time and we will need a buffer to store the image until the conversion is complete.

```rs
use base64::{decode, encode};
use image::ImageOutputFormat::Png;

#[wasm_bindgen]
pub fn grayscale(encoded_file: &str) -> String {
  // decode base 64
  // load image from memory
  // grayscale the image

  // buffer image
  let mut buffer = vec![];
  img.write_to(&mut buffer, Png).unwrap();
  log(&"New image written".into());

  // encode into base64
  let encoded_img = encode(&buffer);
  // convert to data url including metadata
  let data_url = format!(
    "data:image/png;base64,{}",
    encoded_img
  );

  return data_url;
}
```

## Rendering the Image

```javascript
async function init() {
  let rustApp = null;

  try {
    rustApp = await import("../pkg/index.js");
  } catch (error) {
    console.error(error);
    return;
  }

  console.log(rustApp);

  const input = document.getElementById("upload");
  const fileReader = new FileReader();

  input.addEventListener("change", () => {
    fileReader.readAsDataURL(input.files[0]);

    fileReader.onloadend = () => {
      // convert to base64 and remove metadata from the result
      const base64 = fileReader.result.replace(
        /^data:image\/(png|jpeg|jpg);base64,/,
        ""
      );
      let img_data_url = rustApp.grayscale(base64);
      document.getElementById("new-img").setAttribute("src", img_data_url);
    };
  });
}

init();
```

## Deployment

To build the project, we can use the build script. The dist directory is where the build files are located.

```json
"build": "webpack --mode=production"
```

The app is deployed to Vercel
